-- =============================================
-- Settings
-- =============================================
local DIAMOND_ATTRIBUTE_NAME = "Diamond" -- Attribute to display on the counter UI.

-- =============================================
-- Service Definitions
-- =============================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local PathfindingService = game:GetService("PathfindingService")

-- =============================================
-- [NEW] Anti-Cheat Bypass
-- This section attempts to prevent other scripts from teleporting or kicking the player,
-- which can happen if an anti-cheat script detects the fast movement from this script.
-- It works by intercepting calls to TeleportService and blocking them.
-- =============================================
pcall(function()
    local TeleportService = game:GetService("TeleportService")
    local mt = getrawmetatable(TeleportService)
    local oldIndex = mt.__index

    -- We replace the __index metamethod. This function is called whenever a script tries
    -- to access a method of TeleportService (like "Teleport" or "TeleportAsync").
    setmetatable(TeleportService, {
        __index = function(self, key)
            -- Check if the key being accessed is one of the teleport functions.
            if key == "Teleport" or key == "TeleportAsync" or key == "TeleportToPrivateServer" or key == "TeleportToPlaceInstance" then
                -- If it is, we return a new, empty function instead of the real one.
                -- This effectively blocks the teleport call from ever happening.
                return function(...)
                    warn("A script attempted to teleport the player (Reason: " .. tostring(key) .. "). Call was blocked by UpdatedMovementScript.lua to prevent a kick.")
                end
            end
            -- If it's any other property or method, we let it proceed as normal using the original __index.
            return oldIndex(self, key)
        end
    })
    print("Anti-teleport bypass initialized successfully.")
end)

-- =============================================
-- [MODIFIED] Make workspace.Folder cleanup more robust
-- =============================================
-- Initial check in case the folder already exists at script start
local existingFolder = Workspace:FindFirstChild("Folder")
if existingFolder then
    existingFolder:Destroy()
    print("Workspace.Folder found on startup and was deleted.")
end

-- Listen for the folder being added in the future to ensure it's always deleted
Workspace.ChildAdded:Connect(function(child)
    if child.Name == "Folder" then
        task.wait() -- Allow the object to be fully parented before destroying
        child:Destroy()
        print("Workspace.Folder was added and has now been deleted.")
    end
end)


-- Ensure this script only runs on the client
if not RunService:IsClient() then
    return
end

-- =============================================
-- Local Player & Character Setup
-- =============================================
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local inventoryFolder = LocalPlayer:WaitForChild("Inventory")
local NetworkEvent

-- Safely get NetworkEvent
pcall(function()
    NetworkEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("NetworkFramework"):WaitForChild("NetworkEvent")
end)

-- Clean up old UI if it exists
pcall(function()
    if PlayerGui:FindFirstChild("CoordinateUI") then PlayerGui.CoordinateUI:Destroy() end
    if PlayerGui:FindFirstChild("PlayerTeleportGui") then PlayerGui.PlayerTeleportGui:Destroy() end
    if PlayerGui:FindFirstChild("CombinedControlUI") then PlayerGui.CombinedControlUI:Destroy() end
    if PlayerGui:FindFirstChild("ItemCounterGui") then PlayerGui.ItemCounterGui:Destroy() end -- Cleanup for diamond counter
end)

-- =============================================
-- UI Elements (Global Scope)
-- =============================================
local UIElements 
local diamondCountLabel 
local ControlPanelFrame
local playerListFrame 

-- =============================================
-- [เปลี่ยน] ฟังก์ชันเคลื่อนที่ด้วยการเทเลพอร์ต
-- ฟังก์ชันนี้ถูกเปลี่ยนจากการบินมาเป็นการเทเลพอร์ตทันที
-- =============================================
local function teleportTo(destinationPosition)
    task.spawn(function()
        local character = LocalPlayer.Character
        local rootPart = character and character:FindFirstChild("HumanoidRootPart")
        if not rootPart then
            warn("teleportTo failed: Character or HumanoidRootPart not found.")
            return
        end

        -- ย้ายตัวละครทันทีโดยการตั้งค่า CFrame
        rootPart.CFrame = CFrame.new(destinationPosition)
        print("Teleported to " .. tostring(destinationPosition))
    end)
end


-- =============================================
-- Teleport to Player Logic
-- =============================================
local function moveToPlayerObject(targetPlayer)
    local localCharacter = LocalPlayer.Character
    local characterFolder = Workspace:FindFirstChild("Character")
    local targetObject = characterFolder and characterFolder:FindFirstChild(targetPlayer.Name)

    if localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") and targetObject then
        local targetPosition
        if targetObject:IsA("Model") and targetObject.PrimaryPart then
            targetPosition = targetObject.PrimaryPart.CFrame.Position
        elseif targetObject:IsA("BasePart") then
            targetPosition = targetObject.Position
        else
            warn("Could not determine position for target object: '" .. targetObject.Name .. "'")
            return
        end

        local success, err = pcall(function()
            print("Teleporting to " .. targetPlayer.Name .. "'s object...")
            teleportTo(targetPosition + Vector3.new(0, 5, 0))
        end)
        if not success then warn("Movement failed: ", err) end
    else
        if not targetObject then
            print("Movement failed: Cannot find object for player '" .. targetPlayer.Name .. "'")
        else
            print("Movement failed: Local player's character not found.")
        end
    end
end

local function updatePlayerList()
    if not playerListFrame or not playerListFrame.Parent then return end

    local existingButtons = {}
    for _, child in ipairs(playerListFrame:GetChildren()) do
        if child:IsA("TextButton") then existingButtons[child.Name] = child end
    end
    
    local characterFolder = Workspace:FindFirstChild("Character")

    if characterFolder then
        for _, player in ipairs(Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            local targetObject = characterFolder:FindFirstChild(player.Name)
            if targetObject then
                if not existingButtons[player.Name] then
                    local playerButton = Instance.new("TextButton")
                    playerButton.Name = player.Name
                    playerButton.Text = player.DisplayName
                    playerButton.Size = UDim2.new(1, 0, 0, 30)
                    playerButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                    playerButton.TextColor3 = Color3.fromRGB(255, 255, 255)
                    playerButton.Font = Enum.Font.SourceSans
                    playerButton.TextSize = 16
                    playerButton.Parent = playerListFrame
                    playerButton.MouseButton1Click:Connect(function()
                        moveToPlayerObject(player)
                    end)
                end
                existingButtons[player.Name] = nil
            end
        end
    end

    for _, button in pairs(existingButtons) do
        button:Destroy()
    end
end

-- =============================================
-- UI Creation Functions
-- =============================================

-- [MERGED & EDITED] Diamond Counter UI Creation (Moved to the Right)
local function createDiamondCounterUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ItemCounterGui"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    local shadowFrame = Instance.new("Frame")
    shadowFrame.Name = "ShadowFrame"
    shadowFrame.BackgroundColor3 = Color3.new(0, 0, 0)
    shadowFrame.BackgroundTransparency = 0.6
    shadowFrame.BorderSizePixel = 0
    shadowFrame.AnchorPoint = Vector2.new(1, 0) -- Set anchor to top-right
    shadowFrame.Position = UDim2.new(1, -15 + 3, 0, 15 + 3) -- Position from right edge
    shadowFrame.Size = UDim2.new(0, 220, 0, 60)
    shadowFrame.ZIndex = 1
    shadowFrame.Parent = screenGui
    
    local shadowCorner = Instance.new("UICorner")
    shadowCorner.CornerRadius = UDim.new(0, 12)
    shadowCorner.Parent = shadowFrame
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "CounterFrame"
    mainFrame.BackgroundColor3 = Color3.fromRGB(40, 42, 54)
    mainFrame.BorderColor3 = Color3.fromRGB(140, 140, 140)
    mainFrame.BorderSizePixel = 1
    mainFrame.AnchorPoint = Vector2.new(1, 0) -- Set anchor to top-right
    mainFrame.Position = UDim2.new(1, -15, 0, 15) -- Position from right edge
    mainFrame.Size = UDim2.new(0, 220, 0, 60)
    mainFrame.ZIndex = 2
    mainFrame.Parent = screenGui
    
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 12)
    uiCorner.Parent = mainFrame
    
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.Text = DIAMOND_ATTRIBUTE_NAME .. ":"
    titleLabel.TextColor3 = Color3.fromRGB(248, 248, 242)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.TextSize = 24
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Position = UDim2.new(0, 15, 0.5, 0)
    titleLabel.Size = UDim2.new(1, -95, 0, 30)
    titleLabel.AnchorPoint = Vector2.new(0, 0.5)
    titleLabel.Parent = mainFrame
    
    local countLabel = Instance.new("TextLabel")
    countLabel.Name = "Count"
    countLabel.Text = "..."
    countLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
    countLabel.BackgroundTransparency = 1
    countLabel.Font = Enum.Font.SourceSansBold
    countLabel.TextSize = 28
    countLabel.TextXAlignment = Enum.TextXAlignment.Right
    countLabel.Position = UDim2.new(1, -15, 0.5, 0)
    countLabel.Size = UDim2.new(0, 80, 0, 30)
    countLabel.AnchorPoint = Vector2.new(1, 0.5)
    countLabel.Parent = mainFrame
    
    screenGui.Parent = PlayerGui
    
    return countLabel
end

-- Control Panel UI Creation (Responsive)
local function createControlPanelUI()
    local ScreenGui = Instance.new("ScreenGui"); ScreenGui.Name = "CombinedControlUI"; ScreenGui.ResetOnSpawn = false; ScreenGui.Parent = PlayerGui

    -- [MODIFIED] Increased height for the new button
    local frameHeight = 400
    
    -- Main Draggable Frame
    ControlPanelFrame = Instance.new("Frame"); ControlPanelFrame.Name = "ControlPanelFrame";
    ControlPanelFrame.Size = UDim2.new(0, 250, 0, frameHeight)
    ControlPanelFrame.Position = UDim2.new(0.5, 0, 0.5, 0);
    ControlPanelFrame.AnchorPoint = Vector2.new(0.5, 0.5); -- Center the frame
    ControlPanelFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40); ControlPanelFrame.BorderSizePixel = 0; ControlPanelFrame.Active = true; ControlPanelFrame.Draggable = true; ControlPanelFrame.ClipsDescendants = true; ControlPanelFrame.Parent = ScreenGui
    local UICorner_Main = Instance.new("UICorner", ControlPanelFrame); UICorner_Main.CornerRadius = UDim.new(0, 8)

    -- Title Bar
    local TitleBar = Instance.new("Frame"); TitleBar.Name = "TitleBar"; TitleBar.Size = UDim2.new(1, 0, 0, 30); TitleBar.BackgroundColor3 = Color3.fromRGB(45, 45, 60); TitleBar.BorderSizePixel = 0; TitleBar.Parent = ControlPanelFrame
    local UICorner_Title = Instance.new("UICorner", TitleBar); UICorner_Title.CornerRadius = UDim.new(0, 8)
    local TitleLabel = Instance.new("TextLabel"); TitleLabel.Parent = TitleBar; TitleLabel.Name = "TitleLabel"; TitleLabel.Size = UDim2.new(1, -40, 1, 0); TitleLabel.Position = UDim2.new(0, 10, 0, 0); TitleLabel.BackgroundTransparency = 1; TitleLabel.Font = Enum.Font.SourceSansBold; TitleLabel.Text = "Control Panel"; TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255); TitleLabel.TextSize = 18; TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
    local CollapseButton = Instance.new("TextButton"); CollapseButton.Parent = TitleBar; CollapseButton.Name = "CollapseButton"; CollapseButton.Size = UDim2.new(0, 20, 0, 20); CollapseButton.Position = UDim2.new(1, -25, 0.5, -10); CollapseButton.BackgroundColor3 = Color3.fromRGB(60, 60, 75); CollapseButton.Font = Enum.Font.SourceSansBold; CollapseButton.Text = "-"; CollapseButton.TextColor3 = Color3.fromRGB(255, 255, 255); CollapseButton.TextSize = 18
    local UICorner_Collapse = Instance.new("UICorner", CollapseButton); UICorner_Collapse.CornerRadius = UDim.new(0, 4)

    -- Tab Container
    local TabContainer = Instance.new("Frame"); TabContainer.Name = "TabContainer"; TabContainer.Size = UDim2.new(1, 0, 0, 30); TabContainer.Position = UDim2.new(0, 0, 0, 30); TabContainer.BackgroundTransparency = 1; TabContainer.Parent = ControlPanelFrame
    local ControlsTabButton = Instance.new("TextButton"); ControlsTabButton.Name = "ControlsTabButton"; ControlsTabButton.Size = UDim2.new(0.5, 0, 1, 0); ControlsTabButton.BackgroundColor3 = Color3.fromRGB(60, 60, 80); ControlsTabButton.Font = Enum.Font.SourceSansBold; ControlsTabButton.Text = "Controls"; ControlsTabButton.TextColor3 = Color3.fromRGB(255, 255, 255); ControlsTabButton.TextSize = 16; ControlsTabButton.Parent = TabContainer
    local PlayersTabButton = Instance.new("TextButton"); PlayersTabButton.Name = "PlayersTabButton"; PlayersTabButton.Size = UDim2.new(0.5, 0, 1, 0); PlayersTabButton.Position = UDim2.new(0.5, 0, 0, 0); PlayersTabButton.BackgroundColor3 = Color3.fromRGB(40, 40, 50); PlayersTabButton.Font = Enum.Font.SourceSansBold; PlayersTabButton.Text = "Players"; PlayersTabButton.TextColor3 = Color3.fromRGB(200, 200, 200); PlayersTabButton.TextSize = 16; PlayersTabButton.Parent = TabContainer

    -- Content Frames for Tabs
    local ContentContainer = Instance.new("Frame"); ContentContainer.Name = "ContentContainer"; ContentContainer.Size = UDim2.new(1, 0, 1, -60); ContentContainer.Position = UDim2.new(0, 0, 0, 60); ContentContainer.BackgroundTransparency = 1; ContentContainer.Parent = ControlPanelFrame
    
    -- Controls Content
    local ControlsContentFrame = Instance.new("Frame"); ControlsContentFrame.Name = "ControlsContent"; ControlsContentFrame.Size = UDim2.new(1, 0, 1, 0); ControlsContentFrame.BackgroundTransparency = 1; ControlsContentFrame.Parent = ContentContainer; ControlsContentFrame.Visible = true
    local CoordinateLabel = Instance.new("TextLabel"); CoordinateLabel.Parent = ControlsContentFrame; CoordinateLabel.Name = "CoordinateLabel"; CoordinateLabel.Size = UDim2.new(1, -20, 0, 30); CoordinateLabel.Position = UDim2.new(0, 10, 0, 0); CoordinateLabel.BackgroundColor3 = Color3.fromRGB(50, 50, 65); CoordinateLabel.Font = Enum.Font.SourceSansBold; CoordinateLabel.Text = "X: 0.0, Y: 0.0, Z: 0.0"; CoordinateLabel.TextColor3 = Color3.fromRGB(200, 200, 200); CoordinateLabel.TextSize = 16
    local UICorner_CoordLabel = Instance.new("UICorner", CoordinateLabel); UICorner_CoordLabel.CornerRadius = UDim.new(0, 6)
    local InputBox = Instance.new("TextBox"); InputBox.Parent = ControlsContentFrame; InputBox.Name = "InputBox"; InputBox.Size = UDim2.new(1, -70, 0, 30); InputBox.Position = UDim2.new(0, 10, 0, 40); InputBox.BackgroundColor3 = Color3.fromRGB(50, 50, 65); InputBox.Font = Enum.Font.SourceSans; InputBox.Text = "X, Y, Z"; InputBox.TextColor3 = Color3.fromRGB(200, 200, 200); InputBox.TextSize = 16; InputBox.ClearTextOnFocus = true
    local UICorner_InputBox = Instance.new("UICorner", InputBox); UICorner_InputBox.CornerRadius = UDim.new(0, 6)
    local GoButton = Instance.new("TextButton"); GoButton.Parent = ControlsContentFrame; GoButton.Name = "GoButton"; GoButton.Size = UDim2.new(0, 50, 0, 30); GoButton.Position = UDim2.new(1, -60, 0, 40); GoButton.BackgroundColor3 = Color3.fromRGB(0, 150, 200); GoButton.Font = Enum.Font.SourceSansBold; GoButton.Text = "Go"; GoButton.TextColor3 = Color3.fromRGB(255, 255, 255); GoButton.TextSize = 16
    local UICorner_GoBtn = Instance.new("UICorner", GoButton); UICorner_GoBtn.CornerRadius = UDim.new(0, 6)
    local FarmOreButton = Instance.new("TextButton"); FarmOreButton.Parent = ControlsContentFrame; FarmOreButton.Name = "FarmOreButton"; FarmOreButton.Size = UDim2.new(1, -20, 0, 30); FarmOreButton.Position = UDim2.new(0, 10, 0, 80); FarmOreButton.BackgroundColor3 = Color3.fromRGB(0, 170, 80); FarmOreButton.Font = Enum.Font.SourceSansBold; FarmOreButton.Text = "Farm Ore"; FarmOreButton.TextColor3 = Color3.fromRGB(255, 255, 255); FarmOreButton.TextSize = 16
    local UICorner_FarmOreBtn = Instance.new("UICorner", FarmOreButton); UICorner_FarmOreBtn.CornerRadius = UDim.new(0, 6)
    local BuyFoodButton = Instance.new("TextButton"); BuyFoodButton.Name = "BuyFoodButton"; BuyFoodButton.Size = UDim2.new(1, -20, 0, 30); BuyFoodButton.Position = UDim2.new(0, 10, 0, 120); BuyFoodButton.BackgroundColor3 = Color3.fromRGB(255, 180, 0); BuyFoodButton.Font = Enum.Font.SourceSansBold; BuyFoodButton.Text = "Buy Food"; BuyFoodButton.TextColor3 = Color3.fromRGB(255, 255, 255); BuyFoodButton.TextSize = 16; BuyFoodButton.Parent = ControlsContentFrame
    local UICorner_BuyFoodBtn = Instance.new("UICorner", BuyFoodButton); UICorner_BuyFoodBtn.CornerRadius = UDim.new(0, 6)
    local MoveToSellButton = Instance.new("TextButton"); MoveToSellButton.Name = "MoveToSellButton"; MoveToSellButton.Size = UDim2.new(1, -20, 0, 30); MoveToSellButton.Position = UDim2.new(0, 10, 0, 160); MoveToSellButton.BackgroundColor3 = Color3.fromRGB(150, 50, 200); MoveToSellButton.Font = Enum.Font.SourceSansBold; MoveToSellButton.Text = "Sell Point"; MoveToSellButton.TextColor3 = Color3.fromRGB(255, 255, 255); MoveToSellButton.TextSize = 16; MoveToSellButton.Parent = ControlsContentFrame
    local UICorner_MoveSellBtn = Instance.new("UICorner", MoveToSellButton); UICorner_MoveSellBtn.CornerRadius = UDim.new(0, 6)
    local SellLoopButton = Instance.new("TextButton"); SellLoopButton.Name = "SellLoopButton"; SellLoopButton.Size = UDim2.new(1, -20, 0, 30); SellLoopButton.Position = UDim2.new(0, 10, 0, 200); SellLoopButton.BackgroundColor3 = Color3.fromRGB(200, 100, 0); SellLoopButton.Font = Enum.Font.SourceSansBold; SellLoopButton.Text = "Loop Sell"; SellLoopButton.TextColor3 = Color3.fromRGB(255, 255, 255); SellLoopButton.TextSize = 16; SellLoopButton.Parent = ControlsContentFrame
    local UICorner_SellLoopBtn = Instance.new("UICorner", SellLoopButton); UICorner_SellLoopBtn.CornerRadius = UDim.new(0, 6)

    -- [NEW] Blue Label Button
    local BlueLabelButton = Instance.new("TextButton"); BlueLabelButton.Name = "BlueLabelButton"; BlueLabelButton.Size = UDim2.new(1, -20, 0, 30); BlueLabelButton.Position = UDim2.new(0, 10, 0, 240); BlueLabelButton.BackgroundColor3 = Color3.fromRGB(20, 120, 220); BlueLabelButton.Font = Enum.Font.SourceSansBold; BlueLabelButton.Text = "Blue Label"; BlueLabelButton.TextColor3 = Color3.fromRGB(255, 255, 255); BlueLabelButton.TextSize = 16; BlueLabelButton.Parent = ControlsContentFrame
    local UICorner_BlueLabelBtn = Instance.new("UICorner", BlueLabelButton); UICorner_BlueLabelBtn.CornerRadius = UDim.new(0, 6)

    -- Players Content
    local PlayersContentFrame = Instance.new("Frame"); PlayersContentFrame.Name = "PlayersContent"; PlayersContentFrame.Size = UDim2.new(1, 0, 1, 0); PlayersContentFrame.BackgroundTransparency = 1; PlayersContentFrame.Parent = ContentContainer; PlayersContentFrame.Visible = false
    local WalkToKealohaButton = Instance.new("TextButton"); WalkToKealohaButton.Name = "WalkToKealohaButton"; WalkToKealohaButton.Size = UDim2.new(1, -20, 0, 30); WalkToKealohaButton.Position = UDim2.new(0, 10, 0, 5); WalkToKealohaButton.BackgroundColor3 = Color3.fromRGB(220, 120, 0); WalkToKealohaButton.Font = Enum.Font.SourceSansBold; WalkToKealohaButton.Text = "Find KealohaWeaver5712"; WalkToKealohaButton.TextColor3 = Color3.fromRGB(255, 255, 255); WalkToKealohaButton.TextSize = 16; WalkToKealohaButton.Parent = PlayersContentFrame
    local UICorner_WarpKealohaBtn = Instance.new("UICorner", WalkToKealohaButton); UICorner_WarpKealohaBtn.CornerRadius = UDim.new(0, 6)
    playerListFrame = Instance.new("ScrollingFrame"); playerListFrame.Name = "PlayerListFrame"; playerListFrame.Parent = PlayersContentFrame; playerListFrame.Size = UDim2.new(1, -20, 1, -45); playerListFrame.Position = UDim2.new(0, 10, 0, 40); playerListFrame.BackgroundTransparency = 1; playerListFrame.BorderSizePixel = 0; playerListFrame.CanvasSize = UDim2.new(0, 0, 0, 0); playerListFrame.ScrollBarImageColor3 = Color3.fromRGB(180, 180, 180); playerListFrame.ScrollBarThickness = 8
    local listLayout = Instance.new("UIListLayout"); listLayout.Parent = playerListFrame; listLayout.SortOrder = Enum.SortOrder.Name; listLayout.Padding = UDim.new(0, 5); listLayout.FillDirection = Enum.FillDirection.Vertical; listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center

    return {
        ScreenGui = ScreenGui,
        CollapseButton = CollapseButton,
        CoordinateLabel = CoordinateLabel,
        InputBox = InputBox,
        GoButton = GoButton,
        FarmOreButton = FarmOreButton,
        BuyFoodButton = BuyFoodButton,
        MoveToSellButton = MoveToSellButton,
        SellLoopButton = SellLoopButton,
        BlueLabelButton = BlueLabelButton, -- Added new button here
        WalkToKealohaButton = WalkToKealohaButton,
        ControlsTabButton = ControlsTabButton,
        PlayersTabButton = PlayersTabButton,
        ControlsContentFrame = ControlsContentFrame,
        PlayersContentFrame = PlayersContentFrame,
        ControlPanelFrame = ControlPanelFrame -- Return the main frame for resizing
    }
end

-- =============================================
-- Logic & Functions (Merged & Stabilized)
-- =============================================
-- State Variables
local isCollapsed = false
local originalSize = UDim2.new(0, 250, 0, 400) -- Updated size
local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local isOreFarmLoopActive = false
local inventoryConnection = nil
local isWaitingForRockToClear = false
local lastPosition = Vector3.new()
local timeStationary = 0
local antiStuckThreshold = 5
local currentTargetOre = nil
local timeAtOreStationary = 0
local antiStuckAtOreThreshold = 10 
local distanceToOreThreshold = 3
local isSellLoopActive = false -- State for the new sell loop

-- Logic for Diamond Counter
local function setupDiamondCounter(countLabel)
    if not inventoryFolder then 
        warn("Diamond Counter: Inventory folder not found!")
        return
    end

    local function updateAttributeCount()
        local amount = inventoryFolder:GetAttribute(DIAMOND_ATTRIBUTE_NAME) or 0
        countLabel.Text = tostring(amount)
    end

    updateAttributeCount() -- Initial update

    inventoryFolder.AttributeChanged:Connect(function(attributeName)
        if attributeName == DIAMOND_ATTRIBUTE_NAME then
            updateAttributeCount()
        end
    end)
    print("Diamond Counter UI logic initialized.")
end


-- New function to safely create the list of objects to track
local function getObjectsToTrack()
    local trackList = {}
    local farm = Workspace:FindFirstChild("Farm")
    if not farm then
        warn("'Farm' folder not found in Workspace.")
        return trackList
    end

    local rockFolder = farm:FindFirstChild("Rock")
    if not rockFolder then
        warn("'Rock' folder not found in Workspace.Farm.")
        return trackList
    end

    for _, child in ipairs(rockFolder:GetChildren()) do
        if child:IsA("PVInstance") then
            table.insert(trackList, child)
        end
    end
    
    return trackList
end

-- ===================================================================
-- [NEW] Pathfinding function to walk to a specific coordinate
-- This function calculates a path and moves the character along it.
-- ===================================================================
local function walkToPosition(destinationPosition)
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")

    if not (humanoid and rootPart and humanoid.Health > 0) then return end

    print("Walking to position:", destinationPosition, ". Calculating path...")

    local agentParameters = { AgentRadius = 3, AgentHeight = 6, AgentCanJump = true }
    local path = PathfindingService:CreatePath(agentParameters)

    local success, errorMessage = pcall(function()
        path:ComputeAsync(rootPart.Position, destinationPosition)
    end)

    if success and path.Status == Enum.PathStatus.Success then
        print("Path calculated. Following waypoints...")
        local waypoints = path:GetWaypoints()

        local pathBlockedConnection
        local function onPathBlocked(blockedWaypointIndex)
             if blockedWaypointIndex < #waypoints and isWaitingForRockToClear then
                 print("Path blocked at waypoint " .. blockedWaypointIndex .. ". Recalculating...")
                 if pathBlockedConnection then pathBlockedConnection:Disconnect() end
                 walkToPosition(destinationPosition) -- Recalculate and retry
             end
        end
        pathBlockedConnection = path.Blocked:Connect(onPathBlocked)

        for _, waypoint in ipairs(waypoints) do
            -- Check if the process was cancelled (e.g., player manually stopped farming)
            if not isWaitingForRockToClear and not isOreFarmLoopActive then
                print("Process was cancelled mid-path. Aborting walk.")
                break
            end
            humanoid:MoveTo(waypoint.Position)

            if waypoint.Action == Enum.PathWaypointAction.Jump then
                humanoid.Jump = true
            end

            humanoid.MoveToFinished:Wait()
        end

        if pathBlockedConnection then pathBlockedConnection:Disconnect() end
        print("Reached destination or path ended.")
    else
        warn("Pathfinding to position failed: ", errorMessage or "No viable path.", "Using direct walk instead.")
        humanoid:MoveTo(destinationPosition)
        humanoid.MoveToFinished:Wait() -- Also wait for direct move
    end
end


-- Pathfinding walk function to ore
local function findAndWalkToClosestOre(oreToExclude)
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not (humanoid and rootPart and humanoid.Health > 0 and isOreFarmLoopActive) then return end

    task.wait(0.5)

    local objectsToTrack = getObjectsToTrack()
    if #objectsToTrack == 0 then
        warn("No objects to track were found. Aborting walk.")
        currentTargetOre = nil
        return
    end

    local closestObject, minDistance = nil, math.huge
    for _, obj in ipairs(objectsToTrack) do
        if obj and obj.Parent and obj ~= oreToExclude then
            local dist = (rootPart.Position - obj.WorldPivot.Position).Magnitude
            if dist < minDistance then
                minDistance, closestObject = dist, obj
            end
        end
    end

    if closestObject then
        currentTargetOre = closestObject
        print("Walking to closest object:", closestObject:GetFullName(), ". Calculating path...")
        
        local agentParameters = { AgentRadius = 3, AgentHeight = 6, AgentCanJump = true }
        local path = PathfindingService:CreatePath(agentParameters)
        
        local success, errorMessage = pcall(function()
            path:ComputeAsync(rootPart.Position, closestObject.WorldPivot.Position)
        end)

        if success and path.Status == Enum.PathStatus.Success then
            print("Path calculated. Following waypoints...")
            local waypoints = path:GetWaypoints()
            
            local pathBlockedConnection
            local function onPathBlocked(blockedWaypointIndex)
                if blockedWaypointIndex < #waypoints then
                    print("Path blocked at waypoint " .. blockedWaypointIndex .. ". Recalculating...")
                    if pathBlockedConnection then pathBlockedConnection:Disconnect() end
                    findAndWalkToClosestOre(nil)
                end
            end
            pathBlockedConnection = path.Blocked:Connect(onPathBlocked)

            for i, waypoint in ipairs(waypoints) do
                if not isOreFarmLoopActive then
                    print("Farming stopped mid-path. Aborting walk.")
                    break
                end
                humanoid:MoveTo(waypoint.Position)
                humanoid.MoveToFinished:Wait()
            end
            
            if pathBlockedConnection then pathBlockedConnection:Disconnect() end
            print("Reached destination or path ended.")
        else
            warn("Pathfinding to ore failed: ", errorMessage or "No viable path.", "Using direct walk instead.")
            humanoid:MoveTo(closestObject.WorldPivot.Position)
        end
    else
        currentTargetOre = nil
        warn("Could not find any valid objects to walk to (excluding current target).")
    end
end

-- [MODIFIED] Move to Coords using teleport movement
local function moveToCoords(inputBox)
    local parts = inputBox.Text:split(",")
    if #parts == 3 then
        local x, y, z = tonumber(parts[1]), tonumber(parts[2]), tonumber(parts[3])
        if x and y and z then
            teleportTo(Vector3.new(x, y, z))
            inputBox.Text = ""
        else
            inputBox.Text = "Error: Invalid Format"
        end
    else
        inputBox.Text = "Error: Use X,Y,Z"
    end
end

-- Farming coordinates
local initialFarmPosition = Vector3.new(-296, 12, -2489)
local postProcessFarmPosition = Vector3.new(-296, 12, -2489)

-- Farm Step for auto-resume
local function executeResumeFarmStep()
    if not isOreFarmLoopActive then return end
    teleportTo(postProcessFarmPosition) -- Use teleport to get back to the general area
    task.wait(1) -- Wait for teleport to settle
    findAndWalkToClosestOre(nil) -- Then start walking to the nearest ore
end

-- Inventory change handler for farming
local function onInventoryChanged(attributeName, farmButton)
    if not inventoryFolder then return end
    
    local rockCount = inventoryFolder:GetAttribute("Rock") or 0

	if isOreFarmLoopActive and not isWaitingForRockToClear and rockCount >= 100 then
		isWaitingForRockToClear = true
		isOreFarmLoopActive = false -- Pause farming

		farmButton.Text = "Walking to Process..."
		farmButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)

		print("Rock count reached 100. Walking to process point with a 10-second timeout.")
		task.wait(1)

		-- [[[[[ ใหม่: ตรรกะการจับเวลาสำหรับการเดินไปแปรรูป ]]]]]
		local walkCompleted = false
		local walkCancelled = false

		-- Coroutine สำหรับการเดิน เพื่อไม่ให้เทรดหลักค้าง
		task.spawn(function()
			-- สิ่งนี้จะทำงานอยู่เบื้องหลัง
			walkToPosition(postProcessFarmPosition) 
			-- ตรวจสอบว่าไม่ได้ถูกยกเลิกในระหว่างการเดิน
			if isWaitingForRockToClear then 
				walkCompleted = true
			else
				walkCancelled = true
			end
		end)

		-- ลูปสำหรับจับเวลาและตรวจสอบสถานะ
		local timeWaited = 0
		while not walkCompleted and timeWaited < 10 do
			-- ตรวจสอบการยกเลิกด้วยตนเองจาก UI
			if not isWaitingForRockToClear then 
				walkCancelled = true
				break
			end
			task.wait(0.1)
			timeWaited = timeWaited + 0.1
		end
		-- [[[[[ จบ: ตรรกะการจับเวลา ]]]]]
		
		-- ถ้าถูกยกเลิกโดยผู้ใช้
		if walkCancelled then
			print("Walk to process was cancelled by the user.")
			return -- ออกจากฟังก์ชัน สถานะ UI จะถูกจัดการที่อื่น
		end

		-- ถ้าลูปจบลงเพราะหมดเวลา ให้เทเลพอร์ต
		if not walkCompleted then
			print("Walk to process point timed out (>10s). Teleporting to destination...")
			teleportTo(postProcessFarmPosition)
			task.wait(1) -- รอสักครู่เพื่อให้การเทเลพอร์ตเสร็จสิ้น
		else
			print("Walk to process point completed successfully within the time limit.")
		end

		-- ตอนนี้ ไม่ว่าจะมาถึงด้วยวิธีใด (เดิน, หมดเวลา+เทเลพอร์ต) เราจะทำการแปรรูปแร่
		if isWaitingForRockToClear then
			print("Character is at the processing point. Sending 'Process' command to server...")
			NetworkEvent:FireServer("fire", nil, "Process", "Rock")
		else
			-- กรณีนี้ควรถูกดักจับโดย walkCancelled แต่นี่เป็นการป้องกันไว้ก่อน
			print("Walk was cancelled just before processing. Not sending 'Process' command.")
		end

    elseif isWaitingForRockToClear and rockCount == 0 then
        print("Rock inventory cleared. Waiting 5 seconds before resuming farming...")
        task.wait(5)

        if not isWaitingForRockToClear then
            print("Farming was cancelled during the wait. Aborting resume.")
            return
        end
        
        print("Resuming farming...")
        isWaitingForRockToClear = false
        isOreFarmLoopActive = true -- Resume farming

        farmButton.Text = "Stop Farming"
        farmButton.BackgroundColor3 = Color3.fromRGB(200, 40, 40)
        
        executeResumeFarmStep()
    end
end


-- Toggle Farm Loop
local function toggleOreFarmLoop(farmButton)
    isOreFarmLoopActive = not isOreFarmLoopActive
    
    if isOreFarmLoopActive then
        isWaitingForRockToClear = false
        farmButton.Text = "Stop Farming"
        farmButton.BackgroundColor3 = Color3.fromRGB(200, 40, 40)
        
        local currentRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if currentRootPart then
            lastPosition = currentRootPart.Position
            print("Starting farm manually. Teleporting to initial position...")
            teleportTo(initialFarmPosition) -- [MODIFIED]
            task.wait(1) -- Wait for teleport to settle
            findAndWalkToClosestOre(nil)
        end
        timeStationary = 0
        
        if not inventoryConnection then
            inventoryConnection = inventoryFolder.AttributeChanged:Connect(function(attributeName)
                onInventoryChanged(attributeName, farmButton)
            end)
        end
        
        task.spawn(function()
            task.wait(0.5)
            onInventoryChanged("Rock", farmButton)
        end)
        
    else
        isWaitingForRockToClear = false
        farmButton.Text = "Farm Ore"
        farmButton.BackgroundColor3 = Color3.fromRGB(0, 170, 80)
        
        if inventoryConnection then
            inventoryConnection:Disconnect()
            inventoryConnection = nil
        end
    end
end

-- [NEW] Toggle Sell Loop
local function toggleSellLoop(button)
    isSellLoopActive = not isSellLoopActive

    if isSellLoopActive then
        button.Text = "Stop Selling"
        button.BackgroundColor3 = Color3.fromRGB(200, 40, 40) -- Red color for "Stop"

        task.spawn(function()
            print("Sell loop started.")
            while isSellLoopActive do
                if NetworkEvent then
                    pcall(function()
                        NetworkEvent:FireServer("fire", nil, "Economy", "Rockfragments", 50)
                        NetworkEvent:FireServer("fire", nil, "Economy", "Soil", 5)
                        NetworkEvent:FireServer("fire", nil, "Economy", "Iron", 10)
                        NetworkEvent:FireServer("fire", nil, "Economy", "Copper", 10)
                        NetworkEvent:FireServer("fire", nil, "Economy", "Gold", 10)
                    end)
                else
                    warn("Sell Loop: NetworkEvent is not available.")
                    isSellLoopActive = false -- Stop the loop if the event is missing
                    break
                end
                task.wait(0.5) -- Wait half a second before repeating
            end
            -- This part runs after the loop ends
            if button and button.Parent then
                button.Text = "Loop Sell"
                button.BackgroundColor3 = Color3.fromRGB(200, 100, 0) -- Original color
            end
            print("Sell loop stopped.")
        end)
    else
        -- The loop will stop on its own when isSellLoopActive becomes false
    end
end

-- Buy/Sell/Walk Functions
local function buyFood()
    if not NetworkEvent then warn("NetworkEvent not available for buyFood") return end
    teleportTo(Vector3.new(3000, 16, 2280)) -- [MODIFIED]
    task.wait(1)
    NetworkEvent:FireServer("fire", nil, "Supermarket", "Water", 15)
    task.wait(0.2)
    NetworkEvent:FireServer("fire", nil, "Supermarket", "Bread", 15)
end

local function moveToSellPoint()
    local destination = Vector3.new(2853.1, 14.5, 2108.9)
    print("Moving to sell point...")
    teleportTo(destination + Vector3.new(0, 3, 0)) -- [MODIFIED]
end

local function walkToKealoha()
    local targetPlayerName = "KealohaWeaver5712"
    local targetPlayer = Players:FindFirstChild(targetPlayerName)
    
    if not targetPlayer then
        warn("Player " .. targetPlayerName .. " not found in the game.")
        return
    end

    local characterFolder = Workspace:FindFirstChild("Character")
    local targetObject = characterFolder and characterFolder:FindFirstChild(targetPlayer.Name)

    if targetObject then
        local targetPosition
        if targetObject:IsA("Model") and targetObject.PrimaryPart then
            targetPosition = targetObject.PrimaryPart.Position
        elseif targetObject:IsA("BasePart") then
            targetPosition = targetObject.Position
        else
            warn("Could not determine position for target object: '" .. targetObject.Name .. "'")
            return
        end
        
        print("Walking to player: " .. targetPlayer.Name)
        walkToPosition(targetPosition)
    else
        warn("Could not find character object for player: " .. targetPlayer.Name)
    end
end

-- [NEW] Death Recovery Function
local function handleDeathAndRecover()
    task.spawn(function()
        if not isOreFarmLoopActive then
            print("Player died, but farm was not active. No recovery action needed.")
            return
        end

        print("DEATH DETECTED! Starting recovery sequence...")
        toggleOreFarmLoop(UIElements.FarmOreButton)
        
        task.wait(3)

        print("Moving to recovery point (0, -200, 0)...")
        teleportTo(Vector3.new(0, -200, 0)) -- [MODIFIED]

        task.wait(3)

        print("Performing post-recovery key press (1 + Shift)...")
        pcall(function()
            local VirtualInputManager = game:GetService("VirtualInputManager")
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.One, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.One, false, game)
            task.wait(0.5)
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
            print("Post-recovery key press completed.")
        end)

        print("Recovery complete. Auto-restarting farm loop...")
        toggleOreFarmLoop(UIElements.FarmOreButton)
    end)
end

-- =============================================
-- Main Execution & Event Connections
-- =============================================
-- Create UIs
UIElements = createControlPanelUI()
diamondCountLabel = createDiamondCounterUI()

-- Setup Logic
setupDiamondCounter(diamondCountLabel)
originalSize = UIElements.ControlPanelFrame.Size -- Update original size from created UI

-- Connect Death Handler
local humanoid = Character:WaitForChild("Humanoid")
humanoid.Died:Connect(handleDeathAndRecover)
print("Death recovery system connected for initial character.")

-- Update Loop
RunService.RenderStepped:Connect(function(deltaTime)
    if HumanoidRootPart and not isCollapsed then
        local pos = HumanoidRootPart.Position
        UIElements.CoordinateLabel.Text = string.format("X: %.1f, Y: %.1f, Z: %.1f", pos.X, pos.Y, pos.Z)
    end
    if not isOreFarmLoopActive or not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")) then return end
    
    local currentPos = LocalPlayer.Character.HumanoidRootPart.Position
    local isStationary = (currentPos - lastPosition).Magnitude < 0.5

    -- General Anti-Stuck Logic
    if isStationary then
        timeStationary += deltaTime
    else
        timeStationary = 0
        lastPosition = currentPos
    end
    
    if timeStationary >= antiStuckThreshold then
        print("Anti-Stuck Triggered (General). Re-pathing...")
        findAndWalkToClosestOre(nil)
        timeStationary = 0
        timeAtOreStationary = 0
    end

    -- Ore-specific Anti-Stuck Logic
    if currentTargetOre and currentTargetOre.Parent then
        local distToTarget = (currentPos - currentTargetOre.WorldPivot.Position).Magnitude

        if isStationary and distToTarget <= distanceToOreThreshold then
            timeAtOreStationary += deltaTime
            
            if timeAtOreStationary >= antiStuckAtOreThreshold then
                print("Anti-Stuck Triggered (at Ore). Finding next closest ore...")
                findAndWalkToClosestOre(currentTargetOre)
                timeStationary = 0
                timeAtOreStationary = 0
            end
        else
            timeAtOreStationary = 0
        end
    else
        timeAtOreStationary = 0
    end
end)

-- UI Interactions
local function toggleCollapse()
    isCollapsed = not isCollapsed
    local targetSize = isCollapsed and UDim2.new(originalSize.X.Scale, originalSize.X.Offset, 0, 30) or originalSize

    local contentContainer = ControlPanelFrame:FindFirstChild("ContentContainer")
    local tabContainer = ControlPanelFrame:FindFirstChild("TabContainer")

    if contentContainer then contentContainer.Visible = not isCollapsed end
    if tabContainer then tabContainer.Visible = not isCollapsed end

    UIElements.CollapseButton.Text = isCollapsed and "+" or "-"
    TweenService:Create(ControlPanelFrame, tweenInfo, {Size = targetSize}):Play()
end

local function switchTab(tabName)
    local isControls = (tabName == "Controls")
    UIElements.ControlsContentFrame.Visible = isControls
    UIElements.PlayersContentFrame.Visible = not isControls
    UIElements.ControlsTabButton.BackgroundColor3 = isControls and Color3.fromRGB(60, 60, 80) or Color3.fromRGB(40, 40, 50)
    UIElements.ControlsTabButton.TextColor3 = isControls and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(200, 200, 200)
    UIElements.PlayersTabButton.BackgroundColor3 = not isControls and Color3.fromRGB(60, 60, 80) or Color3.fromRGB(40, 40, 50)
    UIElements.PlayersTabButton.TextColor3 = not isControls and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(200, 200, 200)
end

UIElements.CollapseButton.MouseButton1Click:Connect(toggleCollapse)
UIElements.ControlsTabButton.MouseButton1Click:Connect(function() switchTab("Controls") end)
UIElements.PlayersTabButton.MouseButton1Click:Connect(function() 
    switchTab("Players")
    updatePlayerList() -- Update player list when tab is clicked
end)
UIElements.GoButton.MouseButton1Click:Connect(function() moveToCoords(UIElements.InputBox) end)
UIElements.FarmOreButton.MouseButton1Click:Connect(function() toggleOreFarmLoop(UIElements.FarmOreButton) end)
UIElements.BuyFoodButton.MouseButton1Click:Connect(buyFood)
UIElements.MoveToSellButton.MouseButton1Click:Connect(moveToSellPoint)
UIElements.WalkToKealohaButton.MouseButton1Click:Connect(walkToKealoha)
UIElements.SellLoopButton.MouseButton1Click:Connect(function() toggleSellLoop(UIElements.SellLoopButton) end)
-- [NEW] Connect the blue label button
UIElements.BlueLabelButton.MouseButton1Click:Connect(function() 
    print("Moving to Blue Label location...")
    teleportTo(Vector3.new(1936, 15, 2285))
end)


-- [MODIFIED] Keybind to toggle the main control panel changed to 'T'
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end

    if input.KeyCode == Enum.KeyCode.T then
        UIElements.ScreenGui.Enabled = not UIElements.ScreenGui.Enabled
    end
end)


--[[
    [อัปเดต] ระบบกินอาหาร/น้ำดื่มอัตโนมัติโดยใช้ Attributes
    ลูปนี้จะคอยตรวจสอบค่าสถานะ Attributes ของผู้เล่น และจะใช้ไอเทมก็ต่อเมื่อจำเป็นเท่านั้น
]]
task.spawn(function()
    if not NetworkEvent then
        warn("NetworkEvent not found for Smart Auto-Eat loop.")
        return
    end

    while task.wait(5) do -- ตรวจสอบทุกๆ 5 วินาที
        local statusFolder = LocalPlayer:FindFirstChild("Status")
        if statusFolder then
            -- ตรวจสอบค่าความหิว (Hunger) จาก Attribute
            local hungerValue = statusFolder:GetAttribute("Hunger")
            if hungerValue and hungerValue <= 70 then
                print("Hunger is low (" .. string.format("%.2f", hungerValue) .. "), eating bread.")
                NetworkEvent:FireServer("fire", nil, "Use Item", "Bread")
                task.wait(2) -- หน่วงเวลาเล็กน้อยหลังกิน
            end

            -- ตรวจสอบค่าความกระหาย (Thirsty) จาก Attribute
            local thirstyValue = statusFolder:GetAttribute("Thirsty")
            if thirstyValue and thirstyValue <= 70 then
                print("Thirsty is low (" .. string.format("%.2f", thirstyValue) .. "), drinking water.")
                NetworkEvent:FireServer("fire", nil, "Use Item", "Water")
                task.wait(2) -- หน่วงเวลาเล็กน้อยหลังดื่ม
            end
        end
    end
end)


-- Anti-AFK Loop to prevent being kicked for inactivity
task.spawn(function()
    task.wait(60)
    local VirtualInputManager = game:GetService("VirtualInputManager")
    while true do
        task.wait(240) -- Every 4 minutes
        pcall(function()
            -- Simulate pressing Spacebar
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
            
            print("Anti-AFK action performed (Spacebar) to prevent disconnection.")
        end)
    end
end)

-- ====================================================================================
-- [[ NEW ]] Health-Based Recovery Loop
-- This loop listens for the 'MaxHealth' attribute in the Player's Status folder.
-- If MaxHealth drops to 0, it triggers a special recovery sequence.
-- ====================================================================================
task.spawn(function()
    local statusFolder = LocalPlayer:WaitForChild("Status")
    if not statusFolder then
        warn("Health-based recovery: Status folder not found.")
        return
    end

    statusFolder.AttributeChanged:Connect(function(attributeName)
        if attributeName == "MaxHealth" then
            local maxHealthValue = statusFolder:GetAttribute("MaxHealth")
            if maxHealthValue and maxHealthValue == 0 then
                
                -- Spawn a new coroutine to handle the sequence without blocking the event handler
                task.spawn(function()
                    print("MaxHealth reached 0. Initiating special recovery procedure.")

                    -- 1. Stop farming
                    if isOreFarmLoopActive then
                        print("Halting ore farming...")
                        toggleOreFarmLoop(UIElements.FarmOreButton)
                        task.wait(0.5) -- Small delay to ensure state change
                    end

                    -- 2. Go to buy food
                    print("Moving to buy food (Attempt 1)...")
                    buyFood()

                    -- 3. Wait 30 seconds
                    print("Waiting for 30 seconds...")
                    task.wait(30)

                    -- 4. Go to buy food again
                    print("Moving to buy food (Attempt 2)...")
                    buyFood()

                    -- 5. Wait 2 seconds
                    print("Waiting for 2 seconds...")
                    task.wait(2)

                    -- 6. Warp to recovery coordinates
                    local recoveryCoords = Vector3.new(50, -200, 50)
                    print("Warping to recovery location: " .. tostring(recoveryCoords))
                    teleportTo(recoveryCoords)

                    -- 7. Wait 5 seconds
                    print("Waiting for 5 seconds before resuming...")
                    task.wait(5)

                    -- 8. Restart farming
                    if not isOreFarmLoopActive then
                        print("Restarting ore farming...")
                        toggleOreFarmLoop(UIElements.FarmOreButton)
                    end
                    print("Special recovery procedure complete.")
                end)
            end
        end
    end)
    print("Health-based recovery system is active.")
end)


-- Re-establish character parts on respawn and connect death handler
LocalPlayer.CharacterAdded:Connect(function(char)
    Character = char
    HumanoidRootPart = char:WaitForChild("HumanoidRootPart")
    local newHumanoid = char:WaitForChild("Humanoid")
    newHumanoid.Died:Connect(handleDeathAndRecover)
    print("Death recovery system connected for respawned character.")
end)

-- [NEW] Perform a one-time key press when the script starts
task.wait(5) -- Wait 5 seconds for the game to load before pressing keys
print("Performing one-time key press (1 + Shift)...")
pcall(function()
    local VirtualInputManager = game:GetService("VirtualInputManager")
    -- Simulate pressing '1'
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.One, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.One, false, game)
    task.wait(0.5)
    -- Simulate pressing Left Shift
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
    print("One-time key press completed.")
end)

-- Auto-start the farm loop after initial actions
print("Auto-starting farm loop...")
toggleOreFarmLoop(UIElements.FarmOreButton)
